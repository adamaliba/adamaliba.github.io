<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第十六、十七周作业及实验课]]></title>
    <url>%2F2018%2F01%2F02%2F%E7%AC%AC%E5%8D%81%E5%85%AD%E3%80%81%E5%8D%81%E4%B8%83%E5%91%A8%E4%BD%9C%E4%B8%9A%E5%8F%8A%E5%AE%9E%E9%AA%8C%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[实验六（第七章）–复数类（实践1）【问题描述】 自定义一个复数类型Complex，其中含有若干成员函数，使用该类可以完成复数的加法以及对复数的输出。请完成类定义，并编制主函数，说明Complex类对象，对定义的各成员函数进行调用。 class Complex { ​ double real; //复数实部 ​ double imag; //复数虚部 public: ​ Complex (); //无参构造函数，将复数对象的实部和虚部均置为0 ​ Complex (double r, double i); //有参构造函数，设置对象的实部和虚部 ​ Complex AddCom(Complex c2); //调用者对象与对象c2相加，返回Complex类对象 ​ void OutCom () ; //输出调用者对象的有关数据（各分量） }; 具体 要求如下： 1、实现有参构造函数 Complex (double r, double i); 2、实现 Complex AddCom(Complex c2); 调用者对象与对象c2相加，返回Complex类对象 3、实现void OutCom () ;实现输出调用者对象的有关数据分量（一定要输出虚部的符号i），如果该数为纯虚数时,不需要输出实部，当虚部为0时，不需要输出实部。 4．编制主函数main，作用有参函数说明类对象cx,cy，使用 Complex 调用AddCom实现复数加法，并将相加的结果调用 OutCom方法以复数的形式输出。 【输入形式】输入包括a,b,c,d四个整数，第一个复数为a+bi，第二个复数为c+di 【输出形式】 【样例输入】1 2 3 4 【样例输出】4+6i 【程序】 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;class Complex&#123; double real; double imag;public: Complex()&#123;&#125; Complex(double r,double i) &#123; real=r; imag=i; &#125; Complex AddCom(Complex &amp;c2) &#123; real+=c2.real; imag+=c2.imag; &#125; void OutCom() &#123; if(real==0) cout&lt;&lt;imag&lt;&lt;'i'; else if(imag==0) cout&lt;&lt;real; else cout&lt;&lt;real&lt;&lt;'+'&lt;&lt;imag&lt;&lt;'i'; &#125;&#125;;int main()&#123; int a,b,c,d; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; Complex c1(a,b); Complex c2(c,d); c1.AddCom(c2); c1.OutCom(); return 0; &#125; 实验六（第七章）–日期类（实践2）【问题描述】自定义一个简单日期类 DateType，它具有数据成员 y、m、d，用来表示当前日期的年、月、日。而后设计该类欲实现（完成）的功能，进而设计出相应的类成员函数。 class DateType {//自定义的日期类 DateType​ int y,m,d; //数据成员，表示当前日期的年、月、日public:​ DateType(int y0=1, int m0=1, int d0=1);​ //构造函数，设定年、月、日；并设置参数默认值​ void IncrementDay(); //增加 1 天​ bool Equal(DateType dt2); //判断二日期是否相等​ void PrintDate(); //屏幕输出日期对象的有关数据（年、月、日）}; 1、完成有参构造函数2、完成 void IncrementDay()函数，计算天数加1后的日期。3、完成Equal(DateType dt2)函数，判断两个日期是否相等。4、完成打印输出函数PrintDate()，在屏幕上输出日期对象的有关数据（年、月、日）5、编写并完成主函数，实现输入包含六个整数，说明DateType类对象dt1,dt2,分别是dt1和dt2的年月日。请先输出dt1，dt2，然后判断dt1，dt2是否相等，再对dt1,dt2分别增加一天。最后输出dt1，dt2。 注意：在IncrementDay成员函数中，当对日期增加1天后，要注意所谓的“进位”问题：首先算出本“日”所在的月份具有的天数N（注意闰年与平年的2月份天数不一样），若加1之后的“日”数值超过所在的月份具有的天数N时，“进位”到月，而月份若超过12时还要“进位”到年等。【输入形式】 两个日期的月、日、年【输出形式】【样例输入】1 1 1 1999 12 31【样例输出】1:1:11999:12:31False1:1:22000:1:1 【程序】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt; using namespace std; int mon[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;; class DateType &#123; int y,m,d; public: DateType(int y0=1,int m0=1,int d0=1) &#123; y=y0; m=m0; d=d0; &#125; void IncrementDay(); bool Equal(DateType d2); void PrintDate() &#123; cout&lt;&lt;y&lt;&lt;":"&lt;&lt;m&lt;&lt;":"&lt;&lt;d&lt;&lt;endl; &#125; &#125;;void DateType::IncrementDay()&#123; if((y%4==0&amp;&amp;y%100!=0)||(y%400==0)) mon[2]=29; d++; if(d&gt;mon[m]) &#123; m++; d=1; if(m&gt;12) &#123; m=1; y++; &#125; &#125; mon[2]=28;&#125;bool DateType::Equal(DateType d2)&#123; if(y==d2.y&amp;&amp;m==d2.m&amp;&amp;d==d2.d) return true; else return false;&#125;int main() &#123; int d1_y,d1_m,d1_d,d2_y,d2_m,d2_d; cin&gt;&gt;d1_y&gt;&gt;d1_m&gt;&gt;d1_d&gt;&gt;d2_y&gt;&gt;d2_m&gt;&gt;d2_d; DateType dt1(d1_y,d1_m,d1_d),dt2(d2_y,d2_m,d2_d); dt1.PrintDate(); dt2.PrintDate(); if(dt1.Equal(dt2)) cout&lt;&lt;"True"&lt;&lt;endl; else cout&lt;&lt;"False"&lt;&lt;endl; dt1.IncrementDay(); dt2.IncrementDay(); dt1.PrintDate(); dt2.PrintDate(); &#125; 实验六（第七章）–学生类（实践3）【问题描述】设计一个学生类（CStudent），其私有数据成员：注册号、姓名、数学、外语、计算机课程的成绩。公有成员函数是：求三门课总成绩的函数 Sum；求三门课平均成绩的函数 Average；显示学生数据信息的函数 Display；设置学生数据信息的函数 SetData。1．可按如下样式设计 CStudent类的各数据成员以及成员函数class CStudent { //学生类 CStudent​ unsigned long reg_num; //数据成员：注册号​ char name[30]; //数据成员：姓名​ float math, eng, comp; //数据成员：数学、英语、计算机成绩public: //公有成员函数​ float Sum(); //求三门课总成绩的函数 Sum​ float Average(); //求三门课平均成绩的函数 Average​ Display(); //显示学生数据信息的函数 Display​ SetData (unsigned long r, char* n, float m, float e, float c) ;​ //设置学生数据信息的函数 SetData};在主函数，通过使用“CStudent stu[150];”的语句，来说明一个CStudent类对象的数组stu，而后通过各对象stu[i]来处理并求取每一学生的总成绩、平均成绩等。（1）输入本次欲处理的学生人数 TOTAL（小于等于 150 的正整数）；（2）输入全班 TOTAL 个学生的有关信息，依次放入对象数组的各元素 stu[i]中（通过使用“stu[i].SetData(…);”形式的语句来实现）；（3）对全班TOTAL个学生，依次通过对象stu[i]来求出其总成绩、平均成绩等（其中要使用形如“stu[i].Sum()”以及“stu[i].Average()”式样的对成员函数进行调用的语句），并同时求出全班学生总成绩最高者处于 stu 数组的下标位置idx_max，而后通过使用“stu[idx_max].Display();”来输出该学生有关的全部数据信息。3．程序执行后的输入输出界面样式可设计为：TOTAL=3CStudent 1 : 100001 ma 78 86 90（注意空格）CStudent 2 : 100002 li 85 91 88CStudent 3 : 100003 hu 82 89 88CStudent1.Sum=254,CStudent1.average=84.6667CStudent2.Sum=264,CStudent2.average=88CStudent3.Sum=259,CStudent3.average=86.3333class_Sum_max=264The infomation of the CStudent with class_Sum_max : 100002 li 85 91 88【输入形式】TOTAL=3CStudent 1 : 100001 ma 78 86 90（注意空格）CStudent 2 : 100002 li 85 91 88CStudent 3 : 100003 hu 82 89 88【输出形式】CStudent1.Sum=254,CStudent1.average=84.6667CStudent2.Sum=264,CStudent2.average=88CStudent3.Sum=259,CStudent3.average=86.3333class_Sum_max=264The infomation of the CStudent with class_Sum_max : 100002 li 85 91 88 【样例输入】3100001 ma 78 86 90100002 li 85 91 88100003 hu 82 89 88【样例输出】TOTAL=3CStudent 1 : 100001 ma 78 86 90（注意空格）CStudent 2 : 100002 li 85 91 88CStudent 3 : 100003 hu 82 89 88CStudent1.Sum=254,CStudent1.average=84.6667CStudent2.Sum=264,CStudent2.average=88CStudent3.Sum=259,CStudent3.average=86.3333class_Sum_max=264The infomation of the CStudent with class_Sum_max : 100002 li 85 91 88 【程序】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt; #include&lt;string.h&gt; using namespace std; class Cstudent &#123; unsigned reg_num; char name[30]; float math,eng,comp; public: float Sum(); float Average(); void Display(); void setData(unsigned long r, char* n, float m, float e, float c); &#125;; void Cstudent::Display() &#123; cout&lt;&lt;reg_num&lt;&lt;" "&lt;&lt;name&lt;&lt;" "&lt;&lt;math&lt;&lt;" "&lt;&lt;eng&lt;&lt;" "&lt;&lt;comp&lt;&lt;endl; &#125;void Cstudent::setData(unsigned long r, char* n, float m, float e, float c)&#123; reg_num=r; for(int i=0;*(n+i);i++) name[i]=*(n+i); math=m; eng=e; comp=c;&#125;float Cstudent::Sum()&#123; return math+eng+comp;&#125;float Cstudent::Average()&#123; return (math+eng+comp)/3;&#125;int main() &#123; int n;//学生的数量 unsigned long num; char name[30]; float math,eng,comp; float max=0; int max_stu=0;//总成绩最高的学生的下标位置 cin&gt;&gt;n; Cstudent *cp=new Cstudent[n]; //下面代码用于输入每个学生的学号，姓名，数学成绩，英语成绩，计算机成绩，寻找总成绩最高的学生的下标位置 for(int j=0;j&lt;n;j++) &#123; cin&gt;&gt;num&gt;&gt;name&gt;&gt;math&gt;&gt;eng&gt;&gt;comp; cp[j].setData(num,name,math,eng,comp); if(cp[j].Sum()&gt;cp[max_stu].Sum()) max_stu=j; &#125; max=cp[max_stu].Sum();cout&lt;&lt;"TOTAL="&lt;&lt;n&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;"CStudent "&lt;&lt;i+1&lt;&lt;" : "; cp[i].Display(); &#125; int i; for(i=0;i&lt;n;i++) &#123; cout&lt;&lt;"CStudent"&lt;&lt;i+1&lt;&lt;".Sum="&lt;&lt;cp[i].Sum(); cout&lt;&lt;",CStudent"&lt;&lt;i+1&lt;&lt;".average="&lt;&lt;cp[i].Average()&lt;&lt;endl; &#125; cout&lt;&lt;"class_Sum_max="&lt;&lt;max&lt;&lt;endl; cout&lt;&lt;"The infomation of the CStudent with class_Sum_max : "; //输出总成绩最高的学生信息 cp[max_stu].Display();//释放cp delete []cp;&#125; 实验七（第八章）实践题一【问题描述】 对本章示范题的用于管理商店商品的实现程序进行完善:完成Wardrobe立柜类的具体定义与使用，并添加“帽子仓库类”以及“立柜仓库类”的定义及使用，以使程序能够对商店的这三种商品（衬衣、帽子、立柜）进行简单的管理与应用。 要对商品实现的操作有:商品的进库（增加某类商品及其库存量），商品的出库（减少某类商品及其库存量），以及某类商品总价格的计算。 【程序】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include&lt;iomanip&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;using namespace std;class Base&#123; double price; char place[20];public: Base() &#123; price=0; strcpy(place,""); &#125; Base(double pr,char *p1) &#123; price=pr; strcpy(place,p1); &#125; void SetBase(double pr,char *p1) &#123; price=pr; strcpy(place,p1); &#125; void Display() &#123; cout&lt;&lt;price&lt;&lt;' '&lt;&lt;place; &#125; void Input() &#123; cin&gt;&gt;price&gt;&gt;place; &#125; double Getprice() &#123; return price; &#125; char *Getplace() &#123; return place; &#125;&#125;;class Wardrobe:public Base&#123; char material[20]; char color[20];public: Wardrobe():Base() &#123; strcpy(material,""); strcpy(color,""); &#125; Wardrobe(double pr,char *pl, char *mat, char *col) &#123; Base(pr,pl); strcpy(material,mat); strcpy(color,col); &#125; void SetWardrobe(double pr,char *pl, char *mat, char *col) &#123; Base(pr,pl); strcpy(material,mat); strcpy(color,col); &#125; void Display() &#123; Base::Display(); cout&lt;&lt;' '&lt;&lt;material&lt;&lt;' '&lt;&lt;color; &#125; void Input() &#123; Base::Input(); cin&gt;&gt;material&gt;&gt;color; &#125;&#125;;class Shirt:public Base&#123; char material[20];public: Shirt():Base() &#123; strcpy(material,""); &#125; Shirt(double pr, char *pl, char *mat) &#123; Base(pr,pl); strcpy(material,mat); &#125; void SetShirt(double pr,char *pl,char *mat) &#123; Base(pr,pl); strcpy(material,mat); &#125; void Display() &#123; Base::Display(); //调用基类的Display，显示“共性”数据 cout&lt;&lt;' '&lt;&lt;material; &#125; void Input() &#123; Base::Input(); //调用基类的Input cin&gt;&gt;material; &#125; char *GetMaterial() &#123; return material; &#125;&#125;;class Cap:public Shirt&#123; char style;public: Cap():Shirt() &#123; style=' '; &#125; Cap(double pr,char *pl, char *mat, char sty):Shirt(pr,pl,mat) &#123; style=sty; &#125; void SetCap(double pr,char *pl, char *mat, char sty) &#123; SetShirt(pr,pl,mat); style=sty; &#125; void Display() &#123; Shirt::Display(); cout&lt;&lt;' '&lt;&lt;style; &#125; void Input() &#123; Shirt::Input(); cin&gt;&gt;style; &#125;&#125;;const int MAXSIZE=100;class CapStorage&#123; int count; Cap shelf[MAXSIZE];public: CapStorage() &#123; count=0; &#125; void Display() &#123; for(int i=0;i&lt;count;i++) &#123; shelf[i].Display(); cout&lt;&lt;endl; &#125; &#125; void InSomething(int add_cnt) &#123; cout&lt;&lt;add_cnt&lt;&lt;" * Cap data in: price/place/material/style =&gt;"&lt;&lt;endl; shelf[count++].Input(); for(int i=1;i&lt;add_cnt;i++) &#123; shelf[count]=shelf[count-1]; count++; &#125; &#125; void OutSomething(int del_cnt) &#123; count-=del_cnt; &#125; double TotalPrice() &#123; double total=0; for(int i=0;i&lt;count;i++) total+=shelf[i].Getprice(); return total; &#125;&#125;;class WardrobeStorage&#123; int count; Wardrobe shelf[MAXSIZE];public: WardrobeStorage() &#123; count=0; &#125; void Display() &#123; for(int i=0;i&lt;count;i++) &#123; shelf[i].Display(); cout&lt;&lt;endl; &#125; &#125; void InSomething(int add_cnt) &#123; cout&lt;&lt;add_cnt&lt;&lt;" * Wardrobe data in: price/place/material/color =&gt;"&lt;&lt;endl; shelf[count++].Input(); for(int i=1;i&lt;add_cnt;i++) &#123; shelf[count]=shelf[count-1]; count++; &#125; &#125; void OutSomething(int del_cnt) &#123; count-=del_cnt; &#125; double TotalPrice() &#123; double total=0; for(int i=0;i&lt;count;i++) total+=shelf[i].Getprice(); return total; &#125;&#125;;class ShirtStorage&#123; int count; Shirt shelf[MAXSIZE];public: ShirtStorage() &#123; count=0; &#125; void Display() &#123; for(int i=0;i&lt;count;i++) &#123; shelf[i].Display(); cout&lt;&lt;endl; &#125; &#125; void InSomething(int add_cnt) &#123; cout&lt;&lt;add_cnt&lt;&lt;" * shirt data in: price/place/material =&gt;"&lt;&lt;endl; shelf[count++].Input(); for(int i=1;i&lt;add_cnt;i++) &#123; shelf[count]=shelf[count-1]; count++; &#125; &#125; void OutSomething(int del_cnt) &#123; count-=del_cnt; &#125; double TotalPrice() &#123; double total=0; for(int i=0;i&lt;count;i++) total+=shelf[i].Getprice(); return total; &#125;&#125;;int main()&#123; ShirtStorage shiSto; shiSto.InSomething(5); shiSto.InSomething(3); shiSto.Display(); cout&lt;&lt;"shiSto.TotalPrice()="&lt;&lt;shiSto.TotalPrice()&lt;&lt;endl; shiSto.OutSomething(4); shiSto.Display(); cout&lt;&lt;"shiSto.TotalPrice()="&lt;&lt;shiSto.TotalPrice()&lt;&lt;endl; CapStorage capSto; capSto.InSomething(5); capSto.InSomething(3); capSto.Display(); cout&lt;&lt;"capSto.TotalPrice()="&lt;&lt;capSto.TotalPrice()&lt;&lt;endl; capSto.OutSomething(4); capSto.Display(); cout&lt;&lt;"capSto.TotalPrice()="&lt;&lt;capSto.TotalPrice()&lt;&lt;endl; WardrobeStorage warSto; warSto.InSomething(5); warSto.InSomething(3); warSto.Display(); cout&lt;&lt;"WarSto.TotalPrice()="&lt;&lt;warSto.TotalPrice()&lt;&lt;endl; warSto.OutSomething(4); warSto.Display(); cout&lt;&lt;"WarSto.TotalPrice()="&lt;&lt;warSto.TotalPrice()&lt;&lt;endl; return 0;&#125; 实验七（第八章） 实践题二【问题描述】 利用继承性与派生类来管理学生教师档案:由Person（人员）类出发（作为基类），派生出Student（学生）及Teacher（教师）类；而后又由Student（学生）类出发（作为基类），派生出GraduateStudent（研究生）类。可假定这几个类各自具有的数据成员为: Person（人员）类: 姓名、性别、年龄； Student（学生）类: 姓名、性别、年龄、学号、系别； Teacher（教师）类: 姓名、性别、年龄、职称、担任课程； GraduateStudent（研究生）类: 姓名、性别、年龄、学号、系别、导师。 为简化起见，每个类可只设立构造函数以及显示类对象数据的成员函数Print。而后编制简单的主函数，说明上述有关的类对象，并对其类成员函数进行简单使用（调用）。 【输入形式】【输出形式】【样例输入】 无【样例输出】 == per1.Display() =&gt; name,age,sex sun 42 M == stu1.Display() =&gt; name,age,sex,Reg_Number,department guo 22 F 1001 comp == teach1.Display() =&gt; name,age,sex,course,post fang 38 M english professor == gStu.Display() =&gt; name,age,sex,Reg_Number,department,advisor wu 25 M 1021 comp wei 【程序】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;using namespace std;class Person&#123;protected: char name[10]=&#123;0&#125;; char sex; int age;public: Person(char*Name,int Age,char Sex) &#123; age=Age; sex=Sex; for(int i=0;*(Name+i);i++) name[i]=*(Name+i); &#125; void Print() &#123; cout&lt;&lt;name&lt;&lt;" "&lt;&lt;age&lt;&lt;" "&lt;&lt;sex&lt;&lt;endl; &#125;&#125;;class Student:public Person&#123;protected: char Reg_Number[10]=&#123;0&#125;; char department[10]=&#123;0&#125;;public: Student(char*pName,int age,char Sex,char*id,char*depart):Person(pName,age,Sex) &#123; for(int i=0;*(id+i);i++) Reg_Number[i]=*(id+i); for(int j=0;*(depart+j);j++) department[j]=*(depart+j); &#125; void Print() &#123; cout&lt;&lt;name&lt;&lt;" "&lt;&lt;age&lt;&lt;" "&lt;&lt;sex&lt;&lt;" "&lt;&lt;Reg_Number&lt;&lt;" "&lt;&lt;department&lt;&lt;endl; &#125;&#125;;class Teacher:public Person&#123;protected: char post[20]=&#123;0&#125;; char course[20]=&#123;0&#125;;public: Teacher(char*sname,int age,char sex,char*pos,char*cou):Person(sname,age,sex) &#123; for(int j=0;*(pos+j);j++) post[j]=*(pos+j); for(int i=0;*(cou+i);i++) course[i]=*(cou+i); &#125; void Print() &#123; cout&lt;&lt;name&lt;&lt;" "&lt;&lt;age&lt;&lt;" "&lt;&lt;sex&lt;&lt;" "&lt;&lt;post&lt;&lt;" "&lt;&lt;course&lt;&lt;endl; &#125;&#125;;class GraduateStudent:public Student&#123;protected: char dashi[10]=&#123;0&#125;;public: GraduateStudent(char*gname,int age,char sex,char*id,char*depart,char*da):Student(gname,age,sex,id,depart) &#123; for(int i=0;*(da+i);i++) dashi[i]=*(da+i); &#125; void Print() &#123; cout&lt;&lt;name&lt;&lt;" "&lt;&lt;age&lt;&lt;" "&lt;&lt;sex&lt;&lt;" "&lt;&lt;Reg_Number&lt;&lt;" "&lt;&lt;department&lt;&lt;" "&lt;&lt;dashi&lt;&lt;endl; &#125;&#125;;int main()&#123; char name1[20]="sun"; char name2[20]="guo"; char name3[20]="fang"; char name4[20]="wu"; char num1[20]="1001"; char num2[20]="comp"; char num3[20]="1021"; char num4[20]="wei"; char num5[20]="professor"; char num6[20]="english"; cout&lt;&lt;"== per1.Display() =&gt; name,age,sex"&lt;&lt;endl; Person per1(name1,42,'M'); per1.Person::Print(); cout&lt;&lt;"== stu1.Display() =&gt; name,age,sex,Reg_Number,department"&lt;&lt;endl; Student stu1(name2,22,'F',num1,num2); stu1.Student::Print(); cout&lt;&lt;"== teach1.Display() =&gt; name,age,sex,course,post"&lt;&lt;endl; Teacher teach1(name3,38,'M',num6,num5); teach1.Teacher::Print(); cout&lt;&lt;"== gStu.Display() =&gt; name,age,sex,Reg_Number,department,advisor"&lt;&lt;endl; GraduateStudent gStu(name4,25,'M',num3,num2,num4); gStu.Print(); return 0;&#125; 实验七（第八章） 实践题三【问题描述】 自定义一个日期时间类DateTimeType，它含有类DateType与类TimeType的类对象作为其数据成员，并具有所列的其他几个成员函数。而后编制主函数，说明DateTimeType的类对象，并对其成员函数以及二对象成员所属类的公有成员函数进行使用。 class DateTimeType { //自定义的日期时间类 DateTimeType DateType date; //类 DateType 的类对象 date 作为其数据成员 TimeType time; //类 TimeType 的类对象 time 作为其另一个数据成员 public: DateTimeType(int y0=1, int m0=1, int d0=1, int hr0=0, int mi0=0, int se0=0); //构造函数，设定 DateTimeType 类对象的日期时间，并为各参数设置了默认值 DateType&amp; GetDate(){ return date; } //返回本类的私有数据对象 data TimeType&amp; GetTime(){ return time; } //返回本类的私有数据对象 time void IncrementSecond(int s); //增加若干秒，注意“进位”问题 void PrintDateTime(); //屏幕输出日期时间对象的有关数据 }; 注意，每一个DateTimeType类对象中总包含有一个DateType类对象（对象成员）以及一个TimeType类对象（对象成员），编制与实现本程序时，也必须包含DateType与TimeType自定义类（类型）。 之所以设置了公有的类成员函数GetDate与GetTime，是为类外如主函数处使用该类的私有数据成员date与time提供方便（否则的话，类外无法直接访问该类的私有数据成员）。另外，两成员函数返回的都为引用，为的是可将返回对象当作一个独立变量来使用（如可以继续作左值等）。例如，假设编制了如下形式的主函数: void main() { DateTimeType dttm1(1999,12,31,23,59,59), dttm2; (dttm1.GetDate()).PrintDate(); //调用对象成员所属类的公有成员函数 cout&lt;&lt;endl; dttm1.PrintDateTime(); //调用本派生类的成员函数 PrintDateTime dttm2.PrintDateTime(); dttm1.IncrementSecond(30) ; //调用本派生类成员函数 dttm1.PrintDateTime(); } 【输入形式】【输出形式】【样例输入】 无【样例输出】 1999-12-31 1999-12-31 23:59:59 1-1-1 0:0:0 2000-1-1 0:0:29 【程序】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;iostream&gt;using namespace std;class DateType&#123;public: int y,m,d; DateType(int a,int b,int c) &#123; y=a; m=b; d=c; &#125; void PrintDate() &#123; cout&lt;&lt;y&lt;&lt;'-'&lt;&lt;m&lt;&lt;'-'&lt;&lt;d; &#125;&#125;;class TimeType&#123;public: int hr,mi,se; TimeType(int a,int b,int c) &#123; hr=a; mi=b; se=c; &#125; void PrintDate() &#123; cout&lt;&lt;' '&lt;&lt;hr&lt;&lt;':'&lt;&lt;mi&lt;&lt;':'&lt;&lt;se; &#125;&#125;;class DateTimeType&#123; DateType date; TimeType time;public: DateTimeType(int y0=1,int m0=1,int d0=1,int hr0=0,int mi0=0,int se0=0):date(y0,m0,d0),time(hr0,mi0,se0) &#123;&#125; DateType&amp; GetDate() &#123; return date; &#125; TimeType&amp; GetTime() &#123; return time; &#125; void IncrementSecond(int s); void PrintDateTime();&#125;;void DateTimeType::IncrementSecond(int s)&#123; time.se+=s; if(time.se&gt;=60) &#123; time.mi+=time.se/60; time.se%=60; if(time.mi&gt;=60) &#123; time.hr+=time.mi/60; time.mi%=60; if(time.hr&gt;=24) &#123; time.hr%=24; date.d++; if(date.d&gt;=32) &#123; date.d=1; date.m++; if(date.m&gt;12) &#123; date.m=1; date.y++; &#125; &#125; &#125; &#125; &#125;&#125;void DateTimeType::PrintDateTime()&#123; date.PrintDate(); time.PrintDate(); cout&lt;&lt;endl;&#125;int main()&#123; DateTimeType dttm1(1999,12,31,23,59,59), dttm2; (dttm1.GetDate()).PrintDate(); cout&lt;&lt;endl; dttm1.PrintDateTime(); dttm2.PrintDateTime(); dttm1.IncrementSecond(30); dttm1.PrintDateTime(); return 0;&#125; Shape类的继承【问题描述】定义一个Shape基类，在此基础上派生出Rectangle和Circle类，二者都有GetArea（）函数计算对象的面积,使用Rectangle类创建一个派生类Square。并应用相应类的对象测试。【注意：π取3.14】 【输入形式】三种形状基本数据。 【输出形式】对应每种形状的面积。 【程序】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;using namespace std;class Shape &#123; public: Shape()&#123;&#125; ~Shape()&#123;&#125; virtual float GetArea() &#123;return -1;&#125; &#125;; class Circle :public Shape &#123; private: int rad;public: Circle(int radium) &#123; rad = radium; &#125; float GetArea() &#123; return 3.14*rad*rad; &#125;&#125;;class Rectangle:public Shape &#123; private: int len; int hig;public: Rectangle(int length, int hight) &#123; len = length; hig = hight; &#125; float GetArea() &#123; return len*hig; &#125;&#125;;class Square: public Rectangle&#123;public: Square(int side):Rectangle(side,side) &#123;&#125;&#125;;int main() &#123; Shape *sp; int radium,length,hight,side; cin&gt;&gt;radium&gt;&gt;length&gt;&gt;hight&gt;&gt;side; sp=new Circle(radium); cout&lt;&lt;"The area of the circle is "&lt;&lt;sp-&gt;GetArea()&lt;&lt;endl; sp=new Rectangle(length,hight); cout&lt;&lt;"The area of the rectangle is "&lt;&lt;sp-&gt;GetArea()&lt;&lt;endl; sp=new Square(side); cout&lt;&lt;"The area of the Square is "&lt;&lt;sp-&gt;GetArea()&lt;&lt;endl; delete sp; return 0;&#125; 写数据在txt文件中，并计算数据的和【问题描述】在当前目录文件“data.txt”中读取整数数据，并计算总和保存在当前目录的“result.txt”文件中。 【输入形式】文件中的若干数据，格式为按行存储。 【输出形式】输出保存的文件，和计算之和 【程序】 123456789101112131415#include&lt;iostream&gt;#include&lt;fstream&gt; using namespace std;int main()&#123; int a,sum=0; fstream f("data.txt"); while(f&gt;&gt;a) sum+=a; f.close(); fstream p("result.txt",ios::out); p&lt;&lt;sum; p.close(); return 0;&#125; 重载运算符“++”_时钟【程序】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Time&#123;private: unsigned int h,m,s;public: Time(unsigned int a,unsigned int b,unsigned int c) &#123; h=a; m=b; s=c; &#125; Time operator++(int) &#123; s++; if(s&gt;=60) &#123; s=0; m++; if(m&gt;=60) &#123; m=0; h++; if(h&gt;=24) &#123; h=0; m=0; s=0; &#125; &#125; &#125; &#125; void display() &#123; cout&lt;&lt;'\r'&lt;&lt;h&lt;&lt;"时"&lt;&lt;m&lt;&lt;"分"&lt;&lt;s&lt;&lt;"秒"; &#125;&#125;;int main()&#123; unsigned int h,m,s; cin&gt;&gt;h&gt;&gt;m&gt;&gt;s; Time t(h,m,s); while(1) &#123; t.display(); t++; Sleep(1000); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>实验课</tag>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四周作业]]></title>
    <url>%2F2017%2F12%2F21%2F%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%91%A8%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[第九章：学生成绩类2【问题描述】 定义学生成绩类Score，其私有数据成员有学号、姓名、物理、数学、外语、平均成绩。补全Score类及主函数，使得程序能在一行中一次输出该生的学号、姓名、物理、数学、外语、平均成绩。 【输入形式】 输入学生的学号、姓名、物理、数学、外语。 (学号为不超过10位的数字；姓名为长度不超过10位的英文；物理数学外语成绩为0-100的整数) 【输出形式】 输出学生的学号、姓名、物理、数学、外语以及平均成绩。 【样例输入】 081531 WangXiaoming 100 82 99 【样例输出】 081531 WangXiaoming 100 82 99 93.67 【程序】 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstdio&gt; #include &lt;iomanip&gt; using namespace std; class Score &#123;private: string Id, Name; int Phy, Math, Eng; double Ave;public: Score(string id, string name, int phy, int math, int eng):Id(id),Name(name),Phy(phy),Math(math),Eng(eng)&#123;&#125; friend void Average(Score &amp;s1) &#123; s1.Ave=(s1.Phy+s1.Math+s1.Eng)/3.0; &#125; void Print() &#123; cout&lt;&lt;Id&lt;&lt;' '&lt;&lt;Name&lt;&lt;' '&lt;&lt;Phy&lt;&lt;' '&lt;&lt;Math&lt;&lt;' '&lt;&lt;Eng&lt;&lt;' '; printf("%.2f",Ave); &#125;&#125;;int main() &#123; string id, name; int phy, math, eng; cin &gt;&gt; id &gt;&gt; name &gt;&gt; phy &gt;&gt; math &gt;&gt; eng; Score sco(id,name,phy,math,eng); Average(sco); sco.Print();&#125; 第九章：电视类【问题描述】 ​ 补全设计一个TV类和一个Remote类。Remote类的成员函数是TV类的友元， 电视类有状态、频道和音量基本属性，默认初始频道为5，默认初始音量为20。状态有开和关（-1表示关机状态，其他为开机状态）。 ​ 在主函数根据输入的op值进行不同操作。补全代码使程序满足如下要求。 【输入形式】 当op==1时， 输入电视操作命令如下： OFF_ON（切换电视开关机状态） VOL_UP（电视音量+1） VOL_DOWN（电视音量-1） CHA_NEXT（电视频道+1） CHA_PRE(电视频道-1) CHA_TO x（0&lt;=x&lt;=100，将电视频道切到x） VOL_TO x（0&lt;=x&lt;=100，将电视音量切到x） 其中CHA_TO与VOL_TO通过调用友元类实现。 当op==2时，输出当前电视状态。 当op==3时，结束程序。 【输出形式】 当op==2时，输出当前电视状态，具体格式见样例。 【程序】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt; using namespace std; // 前向声明 class TV;// Remote类声明（其中的几个函数为友元） class Remote &#123;public: Remote() &#123;&#125;; void volume_to(TV &amp;tv, int x); void channel_to(TV &amp;tv, int x);&#125;;//TV 类声明 class TV &#123; private: int state; int channel; int volume;public: // 声明友元函数 friend void Remote::volume_to(TV &amp;tv, int x); friend void Remote::channel_to(TV &amp;tv, int x); // 成员函数 TV() &#123;&#125;; TV(int st):state(st),channel(5),volume(20)&#123;&#125;; void onoff()&#123; state*=-1; &#125; void cha_next()&#123; channel++; &#125; void cha_pre()&#123; channel--; &#125; void vol_up()&#123; volume++; &#125; void vol_down()&#123; volume--; &#125; void print()&#123; if(state == -1) &#123; cout&lt;&lt;"The TV is OFF"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;"The TV is ON"&lt;&lt;endl&lt;&lt;"The channel is "&lt;&lt;channel&lt;&lt;endl&lt;&lt;"The volume is "&lt;&lt;volume&lt;&lt;endl; &#125; &#125;&#125;;// 友元函数定义 void Remote::volume_to(TV &amp;tv, int x) &#123; tv.volume = x; &#125;void Remote::channel_to(TV &amp;tv, int x) &#123; tv.channel = x;&#125;int main() &#123; int x,op; string s; TV tv(-1); Remote rem; while(1)&#123; cin&gt;&gt;op; if(op==1)&#123; cin&gt;&gt;s; if(s == "OFF_ON") tv.onoff(); else if(s == "VOL_UP") tv.vol_up(); else if(s == "VOL_DOWN") tv.vol_down(); else if(s == "CHA_NEXT") tv.cha_next(); else if(s == "CHA_PRE") tv.cha_pre(); else if(s == "CHA_TO") &#123; cin&gt;&gt;x; rem.channel_to(tv,x); &#125;else if(s == "VOL_TO")&#123; cin&gt;&gt;x; rem.volume_to(tv,x); &#125; &#125;else if(op ==2)&#123; tv.print(); &#125;else &#123; break; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM 41. Chord]]></title>
    <url>%2F2017%2F12%2F21%2FACM-41-Chord%2F</url>
    <content type="text"><![CDATA[【题目】41. ChordVasya studies music. He has learned lots of interesting stuff. For example, he knows that there are 12 notes: C, C#, D, D#, E, F, F#, G, G#, A, B, H. He also knows that the notes are repeated cyclically: after H goes C again, and before C stands H. We will consider the C note in the row’s beginning and the C note after the H similar and we will identify them with each other. The distance between the notes along the musical scale is measured in tones: between two consecutive notes there’s exactly one semitone, that is, 0.5 tone. The distance is taken from the lowest tone to the uppest one, that is, the distance between C and E is 4 semitones and between E and C is 8 semitones Vasya also knows what a chord is. A chord is an unordered set of no less than three notes. However, for now Vasya only works with triads, that is with the chords that consist of exactly three notes. He can already distinguish between two types of triads − major and minor. Let’s define a major triad. Let the triad consist of notes X, Y and Z. If we can order the notes so as the distance along the musical scale between X and Y equals 4 semitones and the distance between Y and Z is 3 semitones, then the triad is major. The distance between Xand Z, accordingly, equals 7 semitones. A minor triad is different in that the distance between X and Y should be 3 semitones and between Y and Z − 4 semitones. For example, the triad “C E G” is major: between C and E are 4 semitones, and between E and G are 3 semitones. And the triplet “C# B F” is minor, because if we order the notes as “B C# F”, than between B and C# will be 3 semitones, and between C# and F − 4 semitones. Help Vasya classify the triad the teacher has given to him. Input The only line contains 3 space-separated notes in the above-given notation. Output Print “major” if the chord is major, “minor” if it is minor, and “strange” if the teacher gave Vasya some weird chord which is neither major nor minor. Vasya promises you that the answer will always be unambiguous. That is, there are no chords that are both major and minor simultaneously. Examples Input 1C E G Output 1major Input 1C# B F Output 1minor Input 1A B H Output 1strange 【程序】123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int i,x[12];int main()&#123; string s[12]=&#123;"C","C#","D","D#","E","F","F#","G","G#","A","B","H"&#125;,a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(i=0;i&lt;12;i++) if(a==s[i]||b==s[i]||c==s[i]) x[i]=1; for(i=0;i&lt;12;i++) if(x[i]) &#123; if(x[(i+4)%12]&amp;&amp;x[(i+7)%12]) &#123; cout&lt;&lt;"major"; return 0; &#125; if(x[(i+3)%12]&amp;&amp;x[(i+7)%12]) &#123; cout&lt;&lt;"minor"; return 0; &#125; &#125; cout&lt;&lt;"strange";&#125; 【分析】brute force，implementation 难度等级：1 比较简单。思路与算法是一样的，但答案代码有几处精简非常经典切值得学习，直接搬来。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>CGOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM 29. Newspaper Headline]]></title>
    <url>%2F2017%2F12%2F21%2FACM-29-Newspaper-Headline%2F</url>
    <content type="text"><![CDATA[【题目】29. Newspaper HeadlineA newspaper is published in Walrusland. Its heading is s1, it consists of lowercase Latin letters. Fangy the little walrus wants to buy several such newspapers, cut out their headings, glue them one to another in order to get one big string. After that walrus erase several letters from this string in order to get a new word s2. It is considered that when Fangy erases some letter, there’s no whitespace formed instead of the letter. That is, the string remains unbroken and it still only consists of lowercase Latin letters. For example, the heading is “abc”. If we take two such headings and glue them one to the other one, we get “abcabc”. If we erase the letters on positions 1 and 5, we get a word “bcac”. Which least number of newspaper headings s1 will Fangy need to glue them, erase several letters and get word s2? Input The input data contain two lines. The first line contain the heading s1, the second line contains the word s2. The lines only consist of lowercase Latin letters (1≤|s1|≤104,1≤|s2|≤106). Output If it is impossible to get the word s2 in the above-described manner, print “-1” (without the quotes). Otherwise, print the least number of newspaper headings s1, which Fangy will need to receive the word s2. Examples Input 12abcxyz Output 1-1 Input 12abcddabc Output 12 【程序】12345678910111213141516171819202122232425262728293031323334353637383940//2017年12月21日0:26:16// 2017年12月21日0:50:17 #include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;string s1,s2;int test(char *p,char *q)&#123; int i; int a[127]=&#123;0&#125;; for(i=0;*(p+i);i++) a[*(p+i)]++; for(i=0;*(q+i);i++) if(a[*(q+i)]==0) return 0; return 1;&#125;int main()&#123; int i,time=1; cin&gt;&gt;s1&gt;&gt;s2; char *p=&amp;s1[0],*q=&amp;s2[0]; if(test(p,q)) &#123; for(i=0;*(p+i)&amp;&amp;*q;i++) &#123; if(*(p+i)==*q) q++; if(*(p+i+1)==0&amp;&amp;*q) &#123; i=-1; time++; &#125; &#125; cout&lt;&lt;time; &#125; else cout&lt;&lt;-1; return 0; &#125; 【分析】greedy，strings 难度等级：1 比较简单，长时间没刷题了，手生。 先用函数检查子串的元素是否在母串中都存在。用指针在母串中循环比较是否与子串元素相等，每循环一次计数器加一，子串检查完时结束。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>CGOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四周实验课]]></title>
    <url>%2F2017%2F12%2F19%2F%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%91%A8%E5%AE%9E%E9%AA%8C%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[实验五（第六章）字符串统计（实践1）【问题描述】 在进行文章重复度检查时，经常需要统计一段英文中的单词数量，并找出长度最长的单词。 设有如下定义：char str[500]; 编写程序，通过利用cin.getline(str,500);实现从键盘输入一小段英文（其中可以包含空格，但在同一行），利用函数统计该段英文中包含几个单词，输出统计出的单词数量、最长单词的长度以及长度最长的单词，空格隔开。 注意：函数声明使用void split(char *str);如果有最长的单词不只一个，输出最先找到的那个。 【输入形式】一小段英文，不要超过500个字符 【输出形式】单词数量、最长单词的长度以及长度最长的单词，空格隔开。 【样例输入】welcome to china university of mining and technology 【样例输出】8 10 university 【程序】 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;void split(char *str)&#123; int i,j,t=0,l[20],max=0,m=0; for(i=0;*(str+i);i++) &#123; if(*(str+i)==' ') &#123; l[t]=i; t++; &#125; &#125; l[t]=i; max=l[0]; for(j=0;j&lt;t;j++) &#123; if(max&lt;(l[j+1]-l[j])) &#123; max=l[j+1]-l[j]; m=j; &#125; &#125; cout&lt;&lt;t+1&lt;&lt;' '&lt;&lt;max-1&lt;&lt;' '; for(i=l[m]+1;i&lt;l[m+1];i++) cout&lt;&lt;*(str+i); &#125;int main()&#123; char str[500]; cin.getline(str,500); split(str); return 0;&#125; 实验五（第六章）矩阵的转置（实践2）【问题描述】 编程序，按如下方法求A矩阵的转置矩阵B：输入两个正整数m和n，而后通过使用指针配合new运算符生成一个m行n列的二维动态数组A以及另一个n行m列的二维动态数组B，之后为A输入数据（A矩阵数据），逐行逐列输入，进而求出其转置矩阵B（即将A中的行存放成B中的列）并输出结果，逐行逐列输出，每一行数字占一行，同一行的数空格隔开。 注意：输入保证全是整数。 【输入形式】输入m和n,逐行逐列输入数组A的数据【输出形式】逐行逐列输出矩阵B【样例输入】 3 2 119 65 629 679 721 564 【样例输出】 119 629 721 65 679 564 【程序】 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; int m,n,i,j; cin&gt;&gt;m&gt;&gt;n; int (*p)[100]=new int[100][100]; for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) cin&gt;&gt;*(*(p+i)+j); for(j=0;j&lt;n;j++) &#123; for(i=0;i&lt;m;i++) cout&lt;&lt;*(*(p+i)+j)&lt;&lt;' '; cout&lt;&lt;endl; &#125; return 0;&#125; 实验五（第六章）找子串最后一次出现的头字符位置（实践4）【问题描述】 编制具有如下原型的函数findLast： ​ char *findLast(char*sourceStr,char*subStr); findLast函数则要返回源串sourceStr中最后一次出现subStr子字符串的头字符位置。 而后编制主函数，输入两个字符串，将它们用作实参来调用这两个函数，如果返回NULL输出-1，否则输出子字符串出现时头字符在原字符串的下标，每个结果占一行。 要求实现程序中不可使用“string.h”头文件内有关寻找子串的标准库函数。 【输入形式】输入源串sourceStr，子字符串subStr。 【输出形式】子字符串subStr最后一次在源串sourceStr中出现的位置 【样例输入】 ​ welcometochinauniversityofminingandtechnology ​ in 【样例输出】29 【程序】 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;char*findLast(char*sourceStr,char*subStr)&#123; int x=0,y=0,i,j,t=0; while(*(sourceStr+x)) x++; x--; while(*(subStr+y)) y++; y--; for(i=x;i&gt;=0;i--) &#123; if(*(sourceStr+i)==*(subStr+y)) &#123; t=0; for(j=0;j&lt;=y;j++) if(*(sourceStr+i-j)!=*(subStr+y-j)) t++; if(t==0) &#123; return sourceStr+i-j+1; break; &#125; &#125; &#125; return NULL;&#125;int main()&#123; char a[500],b[50],*p; cin&gt;&gt;a; cin&gt;&gt;b; p=findLast(a,b); if(p==NULL) cout&lt;&lt;-1; else cout&lt;&lt;p-a; return 0;&#125; 实验五（第六章）复数提取（实践3）【问题描述】 编写如下原型的函数： void split(double x,int*iPart,double*fPart); 提取出数据x的整数部分与小数部分，分别放于iPart与fPart处，由于形参iPart与fPart都是指针，从而可实现将这两个结果“带回”到主函数中。 在主函数中输入一个数输出它的整数部分和小数部分，用空格隔开。 提示：一个double类型数，强制类型转换后就是int，也就是整数部分，差为小数部分。这两个值用指针iPart和指针fPart带回（通过修改指针的目标变量值。） 【输入形式】一个数 【输出形式】整数部分 小数部分，用空格隔开 【样例输入】12.3【样例输出】12 0.3 【程序】 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;void split(double x,int*iPart,double*fPart)&#123; int a; double b; a=x; b=x-a; *iPart=a; *fPart=b;&#125;int main()&#123; double x,b,*f; int a,*i; cin&gt;&gt;x; f=&amp;b; i=&amp;a; split(x,i,f); cout&lt;&lt;a&lt;&lt;' '&lt;&lt;b; return 0;&#125; 考试题：复数类【问题描述】自定义一个复数类型Complex，其中含有若干成员函数，使用该类可以完成复数的加法以及对复数的输出。请完成类定义，并编制主函数，说明Complex类对象，对定义的各成员函数进行调用。 class Complex { ​ double real; //复数实部 ​ double imag; //复数虚部 public: ​ Complex (); //无参构造函数，将复数对象的实部和虚部均置为0 ​ Complex (double r, double i); //有参构造函数，设置对象的实部和虚部 ​ Complex AddCom(Complex c2); //调用者对象与对象c2相加，返回Complex类对象 ​ void OutCom () ; //输出调用者对象的有关数据（各分量） }; 具体要求如下： 1、实现有参构造函数 Complex (double r, double i); 2、实现 Complex AddCom(Complex c2); 调用者对象与对象c2相加，返回Complex类对象 3、实现void OutCom () ;实现输出调用者对象的有关数据分量（一定要输出虚部的符号i），如果该数为纯虚数时,不需要输出实部，当虚部为0时，不需要输出实部。 4．编制主函数main，作用有参函数说明类对象cx,cy，使用 Complex 调用AddCom实现复数加法，并将相加的结果调用OutCom方法以复数的形式输出。 【输入形式】输入包括a,b,c,d四个整数，第一个复数为a+bi，第二个复数为c+di 【输出形式】 【样例输入】1 2 3 4 【样例输出】4+6i 【样例说明】当实部和虚部为0时不需要输出0，如2i或5。 【程序】 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;class Complex&#123; double real; double imag;public: Complex()&#123;&#125; Complex(double r,double i) &#123; real=r; imag=i; &#125; Complex AddCom(Complex &amp;c2) &#123; real+=c2.real; imag+=c2.imag; &#125; void OutCom() &#123; if(real==0) cout&lt;&lt;imag&lt;&lt;'i'; else if(imag==0) cout&lt;&lt;real; else cout&lt;&lt;real&lt;&lt;'+'&lt;&lt;imag&lt;&lt;'i'; &#125;&#125;;int main()&#123; int a,b,c,d; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; Complex c1(a,b); Complex c2(c,d); c1.AddCom(c2); c1.OutCom(); return 0; &#125; 考试题：字符类查找【问题描述】 假设在main函数中有如下的说明（数组a中存放了n个字符串，即名字）： const int n=10; char a[n][31] = {“guo li”, “li na”, “li qi”, “liu yan”, “ma jing”,”sun li juan”, “wang le”, “wu da”, “yang ke”, “zhang yi fu” }; 编制具有如下原型的自定义函数： int search(char (p)[31], int n, char name); 负责在字符串数组 p 的前 n 个字符串（名字）中，查找给定串 name 的出现位置（下标 值）并返回，若p中不出现 name 的话，返回-1。 并编制主函数，输入要查找的某个名字（字符串）name，而后通过如下形式的语句对上 述函数进行调用，之后输出两个结果，空格隔开（出现位置，即下标值。若没查到时，给出提示:输出-1）： int idx = search(a, n, name); //从 a 数组的第一个名字（0 下标）开始查找 int idx = search(a+3, n-3, name); //从 a 数组的第四个名字（3 下标）开始查找 【输入形式】输入一个字符串 【输出形式】若输入的字符串存在，输出该字符串从第0个和第3个名字开始查找分别出现的位置，不存在输出-1， 【样例输入】guo li 【样例输出】0 -1 【样例说明】提交源文件。 【程序】 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;int search(char (*p)[31], int n, char* name)&#123; int i,j,t=0; for(i=0;i&lt;n;i++) &#123; t=0; for(j=0;*(*(p+i)+j);j++) &#123; if(*(*(p+i)+j)!=*(name+j)) t++; &#125; if(t==0) return i; &#125; return -1;&#125;int main()&#123; const int n=10; char a[n][31] = &#123;"guo li", "li na", "li qi", "liu yan", "ma jing","sun li juan", "wang le", "wu da", "yang ke", "zhang yi fu" &#125;; char name[31]; cin.getline(name,31); int idx= search(a, n, name); cout&lt;&lt;idx&lt;&lt;' '; idx = search(a+3, n-3, name); cout&lt;&lt;idx; return 0;&#125;]]></content>
      <tags>
        <tag>实验课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十三周作业]]></title>
    <url>%2F2017%2F12%2F16%2F%E7%AC%AC%E5%8D%81%E4%B8%89%E5%91%A8%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[课堂作业：类_时钟【程序】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;class Time&#123;private: int Hour,Minute,Second;public: Time(int h=0,int m=0,int s=0); void Show(); void setMinute(); void setHour(); void setAll(); void runSecond();&#125;;Time::Time(int h,int m,int s)&#123; Hour=h;Minute=m;Second=s;&#125; void Time::runSecond()&#123; Second++; if(Second&gt;59) setMinute(); if(Minute&gt;59) setHour(); if(Hour&gt;23) setAll();&#125;void Time::Show()&#123; cout&lt;&lt;'\r'&lt;&lt;Hour&lt;&lt;"时"&lt;&lt;Minute&lt;&lt;"分"&lt;&lt;Second&lt;&lt;"秒"; &#125;void Time::setMinute()&#123; Minute++; Second=0;&#125;void Time::setHour()&#123; Hour++; Minute=0;&#125;void Time::setAll()&#123; Second=0; Minute=0; Hour=0;&#125;int main()&#123; int h,m,s; cin&gt;&gt;h&gt;&gt;m&gt;&gt;s; Time t(h,m,s); while(1) &#123; t.Show(); t.runSecond(); Sleep(1000); &#125; return 0;&#125; 第八章：日期类【问题描述】 ​ 设计一个日期类(Date)，用来实现日期的操作。包括一个空构造函数，三个成员函数，其余所需自行决定。 ​ 用成员函数setDate()用来给Date类设置日期。 ​ 用成员函数isLeapYear()用来判断是否是闰年。 ​ 用成员函数getSkip(Date o)用来计算两个日期之间相差的天数。 【输入形式】 ​ 输入两个日期，输入格式参考样例。 【输出形式】 ​ 判断两个日期是否是闰年，以及两个日期的间隔天数，输出格式参考样例。【样例输入】 ​ 2012 10 20 ​ 2017 11 07 【样例输出】 ​ 2012 is leap year. ​ 2017 is not leap year. ​ The skip of two date is 1844. 【程序】 李寅霜原创 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;using namespace std;class Date&#123; private: int year1,year2; int month1,month2; int day1,day2; public: Date(); void setDate(int a,int b,int c,int x,int y,int z); bool isLeapYear(int); void getSkip(Date o); &#125;;Date::Date()&#123;&#125;void Date::setDate(int a,int b,int c,int x,int y,int z)&#123; year1=a; month1=b; day1=c; year2=x; month2=y; day2=z;&#125;bool Date::isLeapYear(int year)&#123; if((year%4==0&amp;&amp;year%100!=0)||(year%400==0)) return true; else return false;&#125;void Date::getSkip(Date o)&#123; int j=0,sum=0,begin=0; int f[12]=&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; for(j=1;j&lt;o.month1;j++) begin+=f[j-1]; if(isLeapYear(o.year1)) sum++; if(isLeapYear(o.year1)&amp;&amp;o.month1&gt;2) begin++; begin+=o.day1; if(o.year2&gt;o.year1) sum=sum+365; for(j=o.year1+1;j&lt;o.year2;j++) &#123; sum+=365; if(isLeapYear(j)) sum++; &#125; for(j=1;j&lt;o.month2;j++) &#123; sum+=f[j-1]; &#125; if((isLeapYear(o.year2)&amp;&amp;o.month2&gt;2)&amp;&amp;o.year2&gt;o.year1) sum++; sum+=o.day2; cout&lt;&lt;"The skip of two date is "&lt;&lt;sum-begin&lt;&lt;".";&#125;int main()&#123; Date qaq; int x,y,z,a,b,c; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;a&gt;&gt;b&gt;&gt;c; if((x&lt;a)||(x==a&amp;&amp;y&lt;b)||(x==a&amp;&amp;y==b&amp;&amp;z&lt;c)) qaq.setDate(x,y,z,a,b,c); else qaq.setDate(a,b,c,x,y,z); if(qaq.isLeapYear(x)) cout&lt;&lt;x&lt;&lt;" is leap year."&lt;&lt;endl; else cout&lt;&lt;x&lt;&lt;" is not leap year."&lt;&lt;endl; if(qaq.isLeapYear(a)) cout&lt;&lt;a&lt;&lt;" is leap year."&lt;&lt;endl; else cout&lt;&lt;a&lt;&lt;" is not leap year."&lt;&lt;endl; qaq.getSkip(qaq); return 0;&#125; 第八章：三角形类【问题描述】 先定义一个能描述平面上一条线段的类Beeline，包含私有数据成员为线段两个端点的坐标(X1，Y1，X2，Y2)，在类中定义形参默认值为0的构造函数，计算线段长度的公有成员函数Length()，显示线段两个端点坐标的公有成员函数show()。然后再定义一个能描述平面上三角形的类Triangle，其数据成员为用Beeline定义的对象line1，line2，line3。在类中定义的构造函数要能对对象成员进行初始化。再定义计算三角形面积的函数Area()及显示三条边端点坐标及面积的函数Print()，Print()函数中可调用show()函数显示三条边两端点坐标。 【输入形式】 ​ 输入三角形三个顶点的坐标(x1,y1)、(x2,y2)、(x3,y3)。 ​ 其中 -100 &lt;= x1,x2,x3,y1,y2,y3 &lt;= 100，且为整数。 ​ 在主函数中创建类对象tri(x1,y1,x2,y2,x3,y3)，对应line1(x1, y1, x2, y2),line2(x2,y2,x3,y3),line3(x3,y3,x1,y1)。 【输出形式】 ​ 调用Print()函数，将三角形三条边的端点坐标及面积。面积保留两位小数。 ​ 具体格式见样例。 【样例输入】 ​ 0 0 ​ 0 4 ​ 3 0 【样例输出】 ​ Three edges’ points are listed as follows: ​ (0, 0),(0, 4) ​ (0, 4),(3, 0) ​ (3, 0),(0, 0) ​ The area of this triangle is: 6.00. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;math.h&gt;using namespace std;class Beeline&#123;private: int X1,Y1,X2,Y2;public: Beeline(int x1=0,int y1=0,int x2=0,int y2=0); float Length(); void show();&#125;;Beeline::Beeline(int x1,int y1,int x2,int y2)&#123; X1=x1; Y1=y1; X2=x2; Y2=y2;&#125;float Beeline::Length()&#123; return sqrt((X1-X2)*(X1-X2)*1.0+(Y1-Y2)*(Y1-Y2)*1.0);&#125;void Beeline::show()&#123; cout&lt;&lt;"("&lt;&lt;X1&lt;&lt;", "&lt;&lt;Y1&lt;&lt;"),("&lt;&lt;X2&lt;&lt;", "&lt;&lt;Y2&lt;&lt;")"&lt;&lt;endl;&#125;class Triangle&#123;private: Beeline line1,line2,line3;public: Triangle(int x1,int y1,int x2,int y2,int x3,int y3):line1(x1,y1,x2,y2),line2(x2,y2,x3,y3),line3(x3,y3,x1,y1) &#123;&#125; void Area(); void Print();&#125;;void Triangle::Print()&#123; cout&lt;&lt;"Three edges' points are listed as follows:"&lt;&lt;endl; line1.show(); line2.show(); line3.show();&#125;void Triangle::Area()&#123; float p,pa,pb,pc; p=(line1.Length()+line2.Length()+line3.Length())/2; pa=p-line1.Length(); pb=p-line2.Length(); pc=p-line3.Length(); cout&lt;&lt;"The area of this triangle is: "&lt;&lt;setprecision(2)&lt;&lt;std::fixed&lt;&lt;sqrt(p*pa*pb*pc)&lt;&lt;'.';&#125;int main()&#123; int x1,x2,x3,y1,y2,y3; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3; Triangle tri(x1,y1,x2,y2,x3,y3); tri.Print(); tri.Area(); return 0;&#125; 第八章：学生成绩类【问题描述】定义学生成绩类Score，其私有数据成员有学号、姓名、物理、数学、外语、平均成绩。补全Score类及主函数，使得程序能在一行中一次输出该生的学号、姓名、物理、数学、外语、平均成绩。 【输入形式】学生的学号、姓名、物理成绩、数学成绩、外语成绩。 【输出形式】除了输入的所有基本信息，还应包括计算的平均成绩。【样例输入】 ​ 081531 WangXiaoming 100 82 99 【样例输出】 ​ 081531 WangXiaoming 100 82 99 93.6667 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;string&gt; using namespace std; class Score &#123; private: string Id,Name; int Phy,Math,Eng; float Ave;public: Score(string id,string name,int phy,int math,int eng) &#123; Id=id; Name=name; Phy=phy; Math=math; Eng=eng; &#125; void Average() &#123; Ave=(Phy+Math+Eng)/3.0; &#125; void Print() &#123; cout&lt;&lt;Id&lt;&lt;' '&lt;&lt;Name&lt;&lt;' '&lt;&lt;Phy&lt;&lt;' '&lt;&lt;Math&lt;&lt;' '&lt;&lt;Eng&lt;&lt;' '&lt;&lt;Ave; &#125;&#125;;int main() &#123; string id, name; int phy, math, eng; cin &gt;&gt; id &gt;&gt; name &gt;&gt; phy &gt;&gt; math &gt;&gt; eng; Score sco(id, name, phy, math, eng); sco.Average(); sco.Print(); return 0; &#125; 第八章：学生成绩类2【问题描述】设计学生成绩类Score。在主函数中定义学生成绩对象数组s[]。用Sum()计算每个学生的总成绩、用Show()显示每个学生的成绩。增加静态成员函数getAvg()，用于返回学生的总平均分。通过增加合适的成员、修改成员函数等完成这一功能。 【输入形式】 包含一组测试数据。第一行输入一个整数n（1&lt;=n&lt;=100）。 接下来n行。每行先输入一个整数op： 当op==1时，输入x, y, z。代表输入一位新同学i(i从1开始编号)的语文、数学、英语成绩，无需输出。 当op==2时，输入i，输出第i同学的总成绩。数据保证这位同学的成绩已经录入。 当op==3时，输入i，依次输出第i同学的语文数学英语成绩，成绩之间用空格隔开。 当op==4时，输出当前已经录入学生的总平均分，结果保留两位小数。 (1&lt;=n&lt;=100, 1&lt;=id&lt;=10, 1&lt;=op&lt;=3, 0&lt;=x,y,z&lt;=100,全部输入都为整型数) 【输出形式】 当op==2，3，4时，输出所求答案，每个答案占一行。 【样例输入】101 90 85 901 80 90 752 13 241 80 80 851 50 60 651 30 90 753 54 【对应样例输出】 265 80 90 75 255.00 30 90 75 225.00 【程序】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; using namespace std; class Score&#123; private: int Chinese, Math, English; static int TotalScore; static int TotalStudent; public: Score() &#123;&#125; void setScore (int c, int m, int e) &#123; Chinese=c; Math=m; English=e; TotalScore+=c+m+e; TotalStudent++; &#125; int Sum() &#123; return Chinese+Math+English; &#125; void Show() &#123; cout&lt;&lt;Chinese&lt;&lt;' '&lt;&lt;Math&lt;&lt;' '&lt;&lt;English&lt;&lt;endl; &#125; double static getAve() &#123; return TotalScore*1.0/TotalStudent; &#125; &#125;; int Score::TotalScore=0;int Score::TotalStudent=0;int main() &#123; int n, op, i, c, m, e; cin &gt;&gt; n; int id = 1; Score sco[11]; while(n--) &#123; cin &gt;&gt; op; if(op == 1) &#123; cin &gt;&gt; c &gt;&gt; m &gt;&gt; e; sco[id].setScore(c,m,e); id++; &#125; else if(op == 2) &#123; cin &gt;&gt; i; cout&lt;&lt;sco[i].Sum()&lt;&lt;endl; &#125; else if(op == 3) &#123; cin &gt;&gt; i; sco[i].Show(); &#125; else &#123; printf("%.2f\n", sco[i].getAve()); &#125; &#125; return 0; &#125;]]></content>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM 18.Lucky Numbers]]></title>
    <url>%2F2017%2F12%2F12%2FACM-18-Lucky-Numbers%2F</url>
    <content type="text"><![CDATA[【题目】18. Lucky NumbersPetya loves lucky numbers. Everybody knows that positive integers are lucky if their decimal representation doesn’t contain digits other than 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not. Lucky number is super lucky if it’s decimal representation contains equal amount of digits 4 and 7. For example, numbers 47, 7744, 474477 are super lucky and 4, 744, 467 are not. One day Petya came across a positive integer n. Help him to find the least super lucky number which is not less than n. Input The only line contains a positive integer n (1≤n≤10100000). This number doesn’t have leading zeroes. Output Output the least super lucky number that is more than or equal to n. Examples Input 14500 Output 14747 Input 147 Output 147 【程序】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; string a; char *p; long int leng,i,j,k,s4,s7; cin&gt;&gt;a; p=&amp;a[0]; leng=a.size(); if(leng%2!=0) &#123; for(i=0;i&lt;=leng/2;i++) cout&lt;&lt;4; for(i=0;i&lt;=leng/2;i++) cout&lt;&lt;7; &#125; else&#123; s4=leng/2; s7=s4; for(i=0;i&lt;leng;i++) &#123; if(*p&gt;'7') &#123; for(i=0;i&lt;=leng/2;i++) cout&lt;&lt;4; for(i=0;i&lt;=leng/2;i++) cout&lt;&lt;7; goto end; &#125; if(*(p+i)=='4') s4--; if(*(p+i)=='7') s7--; if(*(p+i)&lt;'4') &#123; if(s4==0) &#123; *(p+i-1)+=1; i=0; s4=leng/2; s7=s4; &#125; else &#123; *(p+i)='4'; s4--; break; &#125; &#125; if(*(p+i)&lt;'7'&amp;&amp;*(p+i)&gt;'4') &#123; if(s7==0) &#123; *(p+i-1)+=1; i=0; s4=leng/2; s7=s4; &#125; else &#123; *(p+i)='7'; s7--; break; &#125; &#125; if(*(p+i)&gt;'7') &#123; i--; if(*(p+i)=='4') s4++; if(*(p+i)=='7') s7++; *(p+i)+=1; i--; &#125; if(s4&lt;0||s7&lt;0) &#123; *(p+i-1)+=1; i=0; s4=leng/2; s7=s4; &#125; &#125; for(j=1;j&lt;=s4;j++) *(p+i+j)='4'; for(k=0;k&lt;s7;k++) *(p+i+j+k)='7'; cout&lt;&lt;a; &#125; end: return 0; &#125; 【分析】dp，greedy 难度等级：2 虽然难度只有2，做了3天，最波折的一道题。 一开始没学指针，完全驾驭不了10^9的字符串；遍历也是不可能的。最后把该数字想象为数位上仅有4和7的三进制数，使从左到右的第一个可更改数，小于4时取4，大于4小于7时取7，大于7时进位。同时考虑7和4的数量相同，于是当4或7不够用时，加大这个数字，从头再来一遍，直到4和7刚刚够用。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>CGOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM 24. Frames]]></title>
    <url>%2F2017%2F12%2F12%2FACM-24-Frames%2F</url>
    <content type="text"><![CDATA[【题目】24. FramesThroughout Igor K.’s life he has had many situations worthy of attention. We remember the story with the virus, the story of his mathematical career and of course, his famous programming achievements. However, one does not always adopt new hobbies, one can quit something as well. This time Igor K. got disappointed in one of his hobbies: editing and voicing videos. Moreover, he got disappointed in it so much, that he decided to destroy his secret archive for good. Igor K. use Pindows XR operation system which represents files and folders by small icons. At that, m icons can fit in a horizontal row in any window. Igor K.’s computer contains n folders in the D: disk’s root catalog. The folders are numbered from 1 to n in the order from the left to the right and from top to bottom (see the images). At that the folders with secret videos have numbers from a to b inclusive. Igor K. wants to delete them forever, at that making as few frame selections as possible, and then pressing Shift+Delete exactly once. What is the minimum number of times Igor K. will have to select the folder in order to select folders from a to b and only them? Let us note that if some selected folder is selected repeatedly, then it is deselected. Each selection possesses the shape of some rectangle with sides parallel to the screen’s borders. Input The only line contains four integers n, m, a, b (1≤n,m≤109, 1≤a≤b≤n). They are the number of folders in Igor K.’s computer, the width of a window and the numbers of the first and the last folders that need to be deleted. Output Print a single number: the least possible number of times Igor K. will have to select the folders using frames to select only the folders with numbers from a to b. Examples Input 111 4 3 9 Output 13 Input 120 5 2 20 Output 12 【程序】1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int main()&#123; int n,m,a,b,z=0; cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b; if(b==n) b=n/m*m+m; if((a-1)/m==(b-1)/m) cout&lt;&lt;1; else if((a-1)/m-(b-1)/m==-1) &#123; if((a-1)%m==0&amp;&amp;b%m==0) cout&lt;&lt;1; else cout&lt;&lt;2; &#125; else&#123; z=3; if((a-1)%m==0) z--; if(b%m==0) z--; cout&lt;&lt;z; &#125; return 0; &#125; 【分析】implementation 难度等级：1 第五组数据测试失败，原因是11行两个商减反了。 虽然是一级题，但做起来有困难，主要是把图形转换成商和余数的形式。文件总数n没有意义。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>CGOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM 30. African Crossword]]></title>
    <url>%2F2017%2F12%2F11%2FACM-30-African-Crossword%2F</url>
    <content type="text"><![CDATA[【题目】30. African CrosswordAn African crossword is a rectangular table n×m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded. To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously. When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem. You are suggested to solve an African crossword and print the word encrypted there. Input The first line contains two integers n and m (1≤n,m≤100). Next n lines contain m lowercase Latin letters each. That is the crossword grid. Output Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter. Examples Input 12343 3cbabcdcbc Output 1abcd Input 1234565 5fcofdooedoafaoardcdfeofsf Output 1codeforces 【程序】123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;int main()&#123; int b[100][100]=&#123;0&#125;,i,j,k,l,n,m; char a[100][100]; cin&gt;&gt;n&gt;&gt;m; for(i=0;i&lt;n;i++) for(j=0;j&lt;m;j++) cin&gt;&gt;a[i][j]; for(i=0;i&lt;n;i++) for(j=0;j&lt;m;j++) &#123; if(b[i][j]==0) &#123; for(k=0;k&lt;m;k++) &#123; if(a[i][j]==a[i][k]&amp;&amp;j!=k) &#123; b[i][j]++; b[i][k]++; &#125; &#125; for(l=0;l&lt;n;l++) &#123; if(a[i][j]==a[l][j]&amp;&amp;i!=l) &#123; b[i][j]++; b[l][j]++; &#125; &#125; &#125; &#125; for(i=0;i&lt;n;i++) for(j=0;j&lt;m;j++) if(b[i][j]==0) cout&lt;&lt;a[i][j]; return 0;&#125; 【分析】implementation，strings，难度等级：2 提交一次成功，21分钟12秒完成。 由于是100*100以内的数组，并不需要考虑时间；构造一个与原字符数组等价的计数数组，每个非重复字符检查下行列里是否有重复的，重复者在计数数组相应位置加一，最后按顺序输出计数为零的那些字符。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>CGOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM 3.Hexadecimal's Numbers]]></title>
    <url>%2F2017%2F12%2F11%2FACM-3-Hexadecimal-s-Numbers%2F</url>
    <content type="text"><![CDATA[【题目】3.Hexadecimal’s NumbersOne beautiful July morning a terrible thing happened in Mainframe: a mean virus Megabyte somehow got access to the memory of his not less mean sister Hexadecimal. He loaded there a huge amount of n different natural numbers from 1 to n to obtain total control over her energy. But his plan failed. The reason for this was very simple: Hexadecimal didn’t perceive any information, apart from numbers written in binary format. This means that if a number in a decimal representation contained characters apart from 0 and 1, it was not stored in the memory. Now Megabyte wants to know, how many numbers were loaded successfully. Input Input data contains the only number n (1≤n≤109). Output Output the only number − answer to the problem. Examples Input 110 Output 12 Note For n = 10 the answer includes numbers 1 and 10. 【程序】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;using namespace std;int z=1;void bin(int leng)&#123; int i,t=1; for(i=1;i&lt;leng;i++) t*=2; z+=t; if(leng&gt;1) bin(leng-1); else cout&lt;&lt;z;&#125;int length(int n)&#123; int i=0; while(n&gt;0) &#123; n=n/10; i++; &#125; return i;&#125;int d(int s)&#123; int i=0; while(s&gt;0) &#123; if(s%10!=1&amp;&amp;s%10!=0) i++; s/=10; &#125; return i;&#125;int main()&#123; int n,t=1,i=0,j,s=1,leng; cin&gt;&gt;n; leng=length(n); for(j=1;j&lt;leng;j++) &#123; s*=10; z*=2; &#125; if(s+s/5&lt;n) bin(leng-1); else &#123; while(s&lt;n) &#123; if(t==-1) s+=9; else s+=1; if(d(s)==0&amp;&amp;s&lt;=n) i++; t*=-1; &#125; cout&lt;&lt;i+z; &#125; return 0;&#125; 【分析】brute force，implementation，math]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>CGOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, Hexo!]]></title>
    <url>%2F2017%2F12%2F08%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo+Github搭建博客备忘：​ Hexo 位置 E:blog\ ​ 开启服务器 hexo s 窗口被占用 hexo server -p 5000(端口号) ​ 新建文章 hexo new post “article title” ​ 文章生成及部署 hexo d -g ​ 仍需改进：​ NexT主题更换 ​ 侧边栏配置、图标 ​ 站内搜索功能 ​ 设置作者、站点描述、插入头像图片等 参考博客：​ http://blog.csdn.net/gdutxiaoxu/article/details/53576018 手把手教你用Hexo+Github 搭建属于自己的博客 ​ http://www.jianshu.com/p/e99ed60390a8 20分钟教你使用hexo搭建github博客 ​ http://www.cnblogs.com/fengxiongZz/p/7707219.html 使用Hexo+Github一步步搭建属于自己的博客（基础及进阶） ​ https://hexo.io 官网]]></content>
      <tags>
        <tag>技术实践</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
